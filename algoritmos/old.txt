Custo Uniforme:
    L = PriorityQueue()
    L.put([self.origem])

    while not L.empty():
        caminho = L.get()

        if not caminho:
            return "Busca não foi bem sucedida"

        no = caminho[-1]

        if no == self.destino:
            resultado = Resultado(caminho, self.origem, self.destino)
            return resultado

        for filho in self.conexoes.conexao[no]:
            if filho not in caminho:
                novo_caminho = caminho + [filho]
                L.put(novo_caminho)

    return "Caminho não encontrado


A*:
    open_list = [(0, self.origem)]
    came_from = {}
    g_score = {self.origem: 0}

    while open_list:
        current_cost, current_node = heapq.heappop(open_list)
        if current_node == self.destino:
            path = [current_node]
            while current_node in came_from:
                current_node = came_from[current_node]
                path.append(current_node)
            path.reverse()
            resultado = Resultado(path, self.origem, self.destino)
            return resultado

        for neighbor in self.conexoes.conexao[current_node]:
            tentative_g_score = g_score[current_node] + self.conexoes.conexao[current_node][neighbor]
            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current_node
                g_score[neighbor] = tentative_g_score
                heuristica = PAISES.calcular_distancia_reta(neighbor, self.destino)
                f_score = tentative_g_score + heuristica
                heapq.heappush(open_list, (f_score, neighbor))
    return None


Profundidade Limitada:
    def busca(self, origem, destino, nivel_maximo, caminho_atual=None):
        if caminho_atual is None:
            caminho_atual = []

        caminho_atual = caminho_atual + [origem]

        if origem == destino:
            return caminho_atual

        if len(caminho_atual) > nivel_maximo:
            return None

        for vizinha in self.conexoes.conexao[origem]:
            if vizinha not in caminho_atual:
                novo_caminho = self.busca(vizinha, destino, nivel_maximo, caminho_atual)
                if novo_caminho is not None:
                    return novo_caminho

        return None

    def algoritmo(self):
        novo_caminho = self.busca(self.origem, self.destino, self.profundidade)
        resultado = Resultado(novo_caminho, self.origem, self.destino, self.profundidade)
        return resultado


Procura Sofrega:
    fila_prioridade = [(0, self.origem, [])]
    visitados = set()
    while fila_prioridade:
        custo_atual, localizacao_atual, caminho_atual = heapq.heappop(fila_prioridade)
        if localizacao_atual in visitados:
            continue
        visitados.add(localizacao_atual)
        if localizacao_atual == self.destino:
            return custo_atual, caminho_atual + [localizacao_atual], self.origem, self.destino
        for conexao in self.conexoes:
            if conexao.localizacao1 == localizacao_atual:
                nova_localizacao = conexao.localizacao2
            elif conexao.localizacao2 == localizacao_atual:
                nova_localizacao = conexao.localizacao1
            else:
                continue
            if nova_localizacao not in visitados:
                novo_custo = custo_atual + conexao.heuristica
                novo_caminho = caminho_atual + [localizacao_atual]
                heapq.heappush(fila_prioridade, (novo_custo, nova_localizacao, novo_caminho))
    return float('inf'), [], self.origem, self.destino
